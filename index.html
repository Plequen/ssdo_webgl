<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="Shader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<style>
			body {
				color: #000;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				color: #000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			Mouse left : rotate, middle : zoom, right, right : pan<br/>
			
		</div>
	</body>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth,
			screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 10000;
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, sceneScreen, renderer;
		var lights = [], lightsPos = [], lightsColor = [], lightsIntensity = [];
		var lightsCameras = [], lightsView = [], lightsProj = [], lightsRot = [];
		var shadowMaps = [];
		var objects = [], materials = [];
	
		var rtTexture = [], rttShader = [];
		
		var sphereMesh;
		var phongShader, expressiveShader, zBufferShader;
		var geometryBufferShader, geometryBuffer;
		var normalsAndDepthTexture;
		
		var normalsAndDepthTexture2;
		
		var diffuseMaterialShader;
		var displayManager;
		
		var diffuseMapShader, diffuseTexture;
		
		var ssdoDirectLightingShader, ssdoIndirectBounceShader;
		var directLightBuffer, ssdoFinalBuffer;
		
		var coordsTexture, coordsShader;
		
		var ssdoScene, ssdoQuad;
		
		var shadowMapsResolution = 256;
		var hardShadowsShader, hardShadowsTexture;
		
		var worldMatrixInverse;
		
		var options = {
				minFilter: THREE.LinearFilter,
				//magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				type: THREE.FloatType
			};
		
		//aspect = 1.0;
		
		init();
		animate();
		
		// process lights for shaders
		function processLights() {
			var lightsNumber = lights.length;
			for (var i = 0 ; i < lights.length ; i++) {
				lightsPos[i] = lights[i].getPosition();
				lightsColor[i] = lights[i].getColor();
				lightsIntensity[i] = lights[i].getIntensity();
				
				lightsCameras[i] = new THREE.PerspectiveCamera(70.0, 1.0, 0.1, 1000.0);
				lightsCameras[i].position = lightsPos[i];
				lightsCameras[i].lookAt(lights[i].getLookAt()); 
				
				lightsView[i] = lightsCameras[i].matrixWorldInverse;
				lightsProj[i] = lightsCameras[i].projectionMatrix;
				lightsRot[i] = lightsCameras[i].matrixRotationWorld;
			
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			}
		}
		
		/*function computesUniforms(material) {
			var uniforms = {};
			for (var key in material) {
				uniforms[key] = 
			}
		}*/
		
		// Initialization of the world
		function initScene() {
			scene = new THREE.Scene();
			sceneScreen = new THREE.Scene();
			//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
			
			// lights
			lights[0] = new Light(
				new THREE.Vector3(250, 200, 180),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0),
				1.0
			);
			lights[1] = new Light(
				new THREE.Vector3(-200, 400, 150),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0),
				1.0
			);
			processLights();
			 
			// shaders
			phongShader = new Shader();
			phongShader.setUniform('lightsPos', 'v3v', lightsPos);
			phongShader.setUniform('lightsColor', 'v4v', lightsColor);
			phongShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			phongShader.loadShader('shaders/default.vert', 'vertex');
			phongShader.loadShader('shaders/phong.frag', 'fragment');
			
			expressiveShader = new Shader();
			expressiveShader.setUniform('lightsPos', 'v3v', lightsPos);
			expressiveShader.setUniform('lightsColor', 'v4v', lightsColor);
			expressiveShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			expressiveShader.setShader(phongShader.getShader('vertex'), 'vertex');
			expressiveShader.loadShader('shaders/expressive.frag', 'fragment');
			
			//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
			
			normalsAndDepthTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			normalsAndDepthShader = new Shader();
			normalsAndDepthShader.loadShader('shaders/default.vert', 'vertex');
			normalsAndDepthShader.loadShader('shaders/computesNormalsDepth.frag', 'fragment');
			
			diffuseMaterialShader = new Shader();
			diffuseMaterialShader.setUniform('lightsPos', 'v3v', lightsPos);
			diffuseMaterialShader.setUniform('lightsColor', 'v4v', lightsColor);
			diffuseMaterialShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			diffuseMaterialShader.loadShader('shaders/default.vert', 'vertex');
			diffuseMaterialShader.loadShader('shaders/diffuseMaterial.frag', 'fragment');
			
			// SSDO required inputs
			coordsTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			coordsShader = new Shader();
			coordsShader.loadShader('shaders/computesCoords.vert', 'vertex');
			coordsShader.loadShader('shaders/computesCoords.frag', 'fragment');
			
			diffuseTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			diffuseMapShader = new Shader();
			diffuseMapShader.loadShader('shaders/default.vert', 'vertex');
			diffuseMapShader.loadShader('shaders/diffuseMap.frag', 'fragment');
			

			// shadow mapping
			shadowMapsShader = new Shader();
			shadowMapsShader.loadShader('shaders/shadowMaps.vert', 'vertex');
			shadowMapsShader.loadShader('shaders/shadowMaps.frag', 'fragment');
			var lightProjMatInverse = new THREE.Matrix4();
			lightProjMatInverse.getInverse(lightsProj[0]);
			shadowMapsShader.setUniform('lightsProj', 'm4v', lightsProj);
			
			
			// hard shadows
			hardShadowsTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			hardShadowsShader = new Shader();
			hardShadowsShader.loadShader('shaders/worldCoords.vert', 'vertex');
			hardShadowsShader.loadShader('shaders/hardShadows.frag', 'fragment');
			hardShadowsShader.setUniform('shadowMaps', 'vt', shadowMaps);
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			hardShadowsShader.setUniform('lightsView', 'm4v', lightsView);
			hardShadowsShader.setUniform('lightsProj', 'm4v', lightsProj);
			hardShadowsShader.setUniform('lightsRot', 'm3v', lightsRot);
			hardShadowsShader.setUniform('lightsPos', 'v3v', lightsPos);
			hardShadowsShader.setUniform('lightsColor', 'v4v', lightsColor);
			hardShadowsShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			hardShadowsShader.setUniform('PI', 'f', Math.PI);
			//hardShadowsShader.setUniform('worldMatrix', 'm4', camera.matrixWorldInverse);
			hardShadowsShader.setUniform('screenWidth', 'f', window.innerWidth);
			hardShadowsShader.setUniform('screenHeight', 'f', window.innerHeight);
			
			// SSDO shaders
			directLightBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			ssdoDirectLightingShader = new Shader();
			ssdoDirectLightingShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoDirectLightingShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoDirectLightingShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoDirectLightingShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoDirectLightingShader.loadShader('shaders/SSDODirectLighting.frag', 'fragment');
			ssdoDirectLightingShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoDirectLightingShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoDirectLightingShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoDirectLightingShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoDirectLightingShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoDirectLightingShader.setUniform('projectionM', 'mat4', camera.projectionMatrix);
			//ssdoDirectLightingShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoIndirectBounceShader = new Shader();
			ssdoIndirectBounceShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoIndirectBounceShader.loadShader('shaders/SSDOIndirectBounce.frag', 'fragment');
			ssdoIndirectBounceShader.setUniform('directLightBuffer', 't', directLightBuffer);
			ssdoIndirectBounceShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoIndirectBounceShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoIndirectBounceShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoIndirectBounceShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoIndirectBounceShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoIndirectBounceShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoIndirectBounceShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoIndirectBounceShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoIndirectBounceShader.setUniform('projectionM', 'mat4', camera.projectionMatrix);
			//ssdoIndirectBounceShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoScene = new THREE.Scene();
			var plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
			ssdoQuad = new THREE.Mesh(plane);
			ssdoScene.add(ssdoQuad);
			
			// sphere
			var sphereMaterial = new THREE.MeshLambertMaterial({
				color: 0xCC0000
			});
			var radius = 50, segments = 16, rings = 16;
			
			var sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
			objects[0] = new THREE.Mesh(sphereGeometry);
			materials[0] = [];
			materials[0]['matDiffuse'] = 0.8;
			materials[0]['matSpecular'] = 0.8;
			materials[0]['matEmissive'] = 0.0;
			materials[0]['shininess'] = 5.0;
			materials[0]['matDiffuseColor'] = new THREE.Vector4(1.0, 0.0, 0.0, 1.0);
			materials[0]['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
			materials[0]['matEmissiveColor'] = new THREE.Vector4(0.0, 1.0, 0.0, 1.0);
			scene.add(objects[0]);
			
			var geometry = new THREE.CylinderGeometry(0, 10, 30, 4, 1);
			objects[1] = new THREE.Mesh(geometry);
			objects[1].position.x = -100;
			objects[1].position.z = -100;
			objects[1].position.y = -50;
			materials[1] = materials[0];
			scene.add(objects[1]);
			
			// off importation
			loadOFF('models/monkey.off');
			objects[2].position.x = 150;
			materials[2] = [];
			materials[2]['matDiffuse'] = 0.8;
			materials[2]['matSpecular'] = 0.3;
			materials[2]['matEmissive'] = 0.0;
			materials[2]['shininess'] = 5.0;
			materials[2]['matDiffuseColor'] = new THREE.Vector4(0.2, 1.0, 0.2, 1.0);
			materials[2]['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
			materials[2]['matEmissiveColor'] = new THREE.Vector4(0.0, 1.0, 0.0, 1.0);
			scene.add(objects[2]);
			
			loadOFF('models/ram.off');
			objects[3].position.x = -80;
			objects[3].position.z = 100;
			objects[3].position.y = -50;
			objects[3].rotation.x = - Math.PI / 2;
			materials[3] = jQuery.extend(true, {}, materials[2]);
			materials[3]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.0, 0.5, 1.0);
			scene.add(objects[3]);
			
			loadOFF('models/ground.off', 200);
			objects[4].position.y = -100;
			objects[4].rotation.x = - Math.PI / 2;
			materials[4] = jQuery.extend(true, {}, materials[2]);
			materials[4]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.5, 0.5, 1.0);
			scene.add(objects[4]);
			
			//phongShader.setAttribute('displacement', 'f', []);
			// now populate the array of attributes
			/*var vertices = sphere.geometry.vertices;
			var values = attributes.displacement.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 30);
			}*/
			
			// displays for the different renderings
			rtTexture[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			rtTexture[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			rtTexture[2] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			displayManager = new DisplayManager(sceneScreen, {type: 'GRID', cols: 2, rows: 3});
			//displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepth.frag');
			//displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayNormals.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepthNormals.frag');
			displayManager.addSimpleTexture(rtTexture[0]);
			//displayManager.addSimpleTexture(rtTexture[1]);
			//displayManager.addSimpleTexture(rtTexture[2]);
			//displayManager.addSimpleTexture(diffuseTexture);
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag');
			displayManager.addSimpleTexture(hardShadowsTexture);
			//displayManager.addSimpleTexture(directLightBuffer);
			//displayManager.addSimpleTexture(ssdoFinalBuffer);
			displayManager.organize();
		}
		
		// Initialization
		function init() {
			// camera
			camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
			//camera.position.x = 200;
			camera.position.y = 200;
			camera.position.z = 300;
			
			
			cameraRTT = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000);
			cameraRTT.position.z = 100;
			
			// controls
			controls = new THREE.TrackballControls(camera);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];
			controls.addEventListener('change', render);
			
			// world
			initScene();
			
			// renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xFFFFFF, 1);
			renderer.setSize(screenWidth, screenHeight);

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			
			// display
			$container = $('#container');
			$container.append(renderer.domElement);
			$container.append(stats.domElement);
			
			window.addEventListener('resize', onWindowResize, false);
			window.addEventListener('keydown', keyDown, false);
		}
		
		function keyDown(event) {
			if (event.keyCode == 96) {
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 3});
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) {
				displayManager.changeMode({type: 'SINGLE', id: (event.keyCode - 97)});
			}
			render();
		}
	
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			/*if (currentTime - lastTime >= interval) {
				if (objects[0].position.y >= 100)
					direction = -1;
				if (objects[0].position.y <= -50)
					direction = 1;
				objects[0].position.y += direction * 5;
				lastTime = currentTime;
				render();
			}*/
			//worldMatrixInverse.getInverse(camera.matrixWorldInverse);
			controls.update();
			stats.update();
		}
		
		function render() {
			// 1st rendering : computes depth and normals
			for (var i = 0 ; i < objects.length ; i++)
				objects[i].setMaterial(normalsAndDepthShader.getMaterial());
			renderer.render(scene, camera, normalsAndDepthTexture, true);
			
			// 2nd rendering : complete rendering
			for (var i = 0 ; i < objects.length ; i++) {
				phongShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				phongShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
				phongShader.setUniform('matEmissive', 'f', materials[i]['matEmissive']);
				phongShader.setUniform('shininess', 'f', materials[i]['shininess']);
				phongShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				phongShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
				phongShader.setUniform('matEmissiveColor', 'v4', materials[i]['matEmissiveColor']);
				objects[i].setMaterial(phongShader.createMaterial());
			}
			renderer.render(scene, camera, rtTexture[0], true);
			
			// 3rd rendering : expressive rendering for the sphere
			for (var i = 0 ; i < objects.length ; i++) {
				expressiveShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				expressiveShader.setUniform('shininess', 'f', materials[i]['shininess']);
				expressiveShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(expressiveShader.createMaterial());
			}
			renderer.render(scene, camera, rtTexture[1], true);
			
			// 4th rendering : diffuse material rendering
			for (var i = 0 ; i < objects.length ; i++) {
				diffuseMaterialShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				diffuseMaterialShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(diffuseMaterialShader.createMaterial());
			}
			renderer.render(scene, camera, rtTexture[2], true);
			
			// 5th rendering : diffuse map rendering
			for (var i = 0 ; i < objects.length ; i++) {
				diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(diffuseMapShader.createMaterial());
			}
			renderer.render(scene, camera, diffuseTexture, true);
			
			// shadow maps
			//shadowMapsShader.setUniform('lightView', 'm4', lightsView[0]);
			//shadowMapsShader.setUniform('lightProj', 'm4', lightsProj[0]);
			for (var i = 0 ; i < objects.length ; i++) {
				objects[i].setMaterial(shadowMapsShader.getMaterial());
			}
			renderer.render(scene, lightsCameras[0], shadowMaps[0], true);
			renderer.render(scene, lightsCameras[1], shadowMaps[1], true);
			
			for (var i = 0 ; i < objects.length ; i++) {
				hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
				hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
				hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
				objects[i].setMaterial(hardShadowsShader.createMaterial());
			}
			renderer.render(scene, camera, hardShadowsTexture, true);
			
			// SSDO
			// computes 3D coords
			for (var i = 0 ; i < objects.length ; i++) {
				objects[i].setMaterial(coordsShader.getMaterial());
			}
			renderer.render(scene, camera, coordsTexture, true);
			
			
///////////////
			/*
			// ssdo 1st pass
			ssdoQuad.setMaterial(ssdoDirectLightingShader.getMaterial());
			renderer.render(ssdoScene, cameraRTT, directLightBuffer, true);
			// ssdo 2nd pass
			ssdoQuad.setMaterial(ssdoIndirectBounceShader.getMaterial());
			renderer.render(ssdoScene, cameraRTT, ssdoFinalBuffer, true);
			*/
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		function loadOFF(fileName, _scale) {
			$.ajax({
				url: fileName,
				async: false,
				dataType: 'text',
				context: {
					scale: _scale
				},
				complete: processOFF
			});
		}
		
		function processOFF(jqXHR, textStatus) {
			var geometry = new THREE.Geometry();
			var lines = jqXHR.responseText.split("\n");
			if (lines[0] != "OFF")
					alert('Not an OFF file');
			else {
				var scale = 50;
				if (this.scale != null)
					scale = this.scale;
					
				var params = lines[1].split(" ");
				// params[0] : number of vertices
				// params[1] : number of triangles
				// params[2] : number of what
				/*alert("lines : " + lines.length + "\n" +
					"vertices : " + params[0] + "\n" + 
					"faces : " + params[1] + "\n" + 
					"what : " + params[2]);*/
				for (var i = 0 ; i < params[0] ; i++) {
					var coords = lines[2 + i].split(" ");
					geometry.vertices.push(new THREE.Vector3(scale * coords[0], scale * coords[1], scale * coords[2]));
				}
				for (var i = 0 ; i < params[1] ; i++) {
					var indexes = lines[2 + parseInt(params[0]) + i].split(" ");
					// [0] : polygon size
					geometry.faces.push(new THREE.Face3(indexes[1], indexes[2], indexes[3]));
				}
				geometry.computeFaceNormals();
				
				var objectID = objects.length;
				objects[objectID] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial());
				scene.add(objects[objectID]);
			}
		}
	</script>
</html>
<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/FirstPersonControls.js"></script>
		<script src="lib/FlyControls.js"></script>
		<script src="lib/PointerLockControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/MTLLoaderP.js"></script>
		<script src="lib/OBJMTLLoader.js"></script>
		<script src="Random.js"></script>
		<script src="OFF.js"></script>
		<script src="Shader.js"></script>
		<script src="PhongShader.js"></script>
		<script src="ExpressiveShader.js"></script>
		<script src="DiffuseShader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<script src="Scene.js"></script>
		<link rel="stylesheet" href="css/main.css" />  
	</head>
	<body>
		<div id="container"></div>
	</body>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 10000;
			
		var lightDefaultAngle = 60.0, skyLightIntensity = 0.1, 
			lightDefaultAttenuation = 0.4, lightDefaultIntensity = 1.0;
		var lightViewAngle = 70.0, lightRatio = 1.0, lightNear = 0.1, lightFar = 1000.0;
		var cameraSpeed = 10.0;
		var clock = new THREE.Clock();
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, sceneScreen, renderer, displayManager;
		var lights = [], lightsPos = [], lightsColor = [], lightsIntensity = [];
		var lightsAngle = [], lightsAttenuation = [];
		var lightsCameras = [], lightsView = [], lightsProj = [];
		var objects = [], materials = [];
		var blankMaterial = []; blankMaterial['matDiffuse'] = 0.8; blankMaterial['matSpecular'] = 0.3;
		blankMaterial['matEmissive'] = 0.0; blankMaterial['shininess'] = 5.0;
		blankMaterial['matDiffuseColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matEmissiveColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['texture'] = null;
		
		var shaders = [], rtTextures = [];
		var normalsAndDepthShader, normalsAndDepthTexture;
		var diffuseMapShader, diffuseTexture;
		var materialShader, materialTexture;
		var coordsShader, coordsTexture;
		var texturedPhong, texturedPhongTexture;

		var secondDepthShader, secondDepthTexture;		
		var shadowMaps = [], shadowMapsResolution = 64, shadowMapsFullResolution = 256;
		var shadowMapAux, shadowMapAux2, shadowMapBlurShader, blurShadowMaps = false;
		var smScene, shadowMapsBlurSize = 4.0;

		var hardShadowsShader, hardShadowsTexture;
		var shadowMapsDownSampled = [];
		
		var dofScene, dofQuad;
		var DOFBlurTexture, DOFBlurShader;
		var DOFImageTexture, DOFImageShader;
		var dofAuxTexture, dofResolution = 256;
		
		var worldToMillimeter = 10;
		var camMill = 35;
		//var focal = 50;
		var focal = 180 * camMill / (Math.PI * viewAngle);
		focal = 80;
		var focusDistance = 380, blurCoeff;
		//var ppm = 36.57;
		var ppm = Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight) / camMill;
		//var fStop = 2.8,
		var fStop = ppm;
		fStop = 20;
		
		var ssaoScene, ssaoQuad;
		var ssaoOnlyShader, ssaoOnlyBuffer;
		var ssaoDiffuseShader, ssaoDiffuseBuffer;

		var ssdoScene, ssdoQuad;
		var ssdoDirectLightingShader, directLightBuffer;
		var ssdoIndirectBounceShader, ssdoIndirectBounceBuffer;
		var ssdoBlurShader, ssdoBlurBuffer, ssdoBlurAuxBuffer;
		var ssdoFinalShader, ssdoFinalBuffer;
		
		var scenes = [];
		var currentScene = "scene1";
		
				
		var customDisplays = [];
		customDisplays['normal'] = {cols: 2	, rows: 3, 
			names: ['depth', 'normals', 'depthAndNormals', 'diffuseMap', 'diffuse', 'phong']};
		customDisplays['all'] = {cols: 4, rows: 4, all: true};
		customDisplays['shadows'] = {cols: 2, rows: 2, 
			names: ['shadowMap1', 'shadowMap2', 'hardShadows', 'phong']};
		customDisplays['ssdo'] = {cols: 2, rows: 2, 
			names: ['shadowMap1', 'ssdoDirect', 'ssdoBlur', 'ssdoFinal']};

		customDisplays['ssao'] = {cols: 2, rows: 2, 
			names: ['ssaoOnly', 'ssaoDiffuse', 'depth', 'secondDepth']};
		
		customDisplays['dof'] = {cols: 2, rows: 2, 
			names: ['dofBlurAux', 'dofBlur', 'dofImage', 'hardShadows']};
			
		customDisplays['texture'] = {names: ['diffuseMap']};
		customDisplays['random'] = {names: ['random']};
		
		var MODE = 'ssdo', ANIMATION = false;
		var shadowMode = 0; // hardShadows
		
		var randomDirectionsTexture, randomTexture;
		
		//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
		var options = {
				minFilter: THREE.LinearFilter,
				//magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				type: THREE.FloatType
			};
		var blankTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
		var testTexture = THREE.ImageUtils.loadTexture('textures/avatar.jpg');
		var fizzyText; // controls
	</script>
	<script src="Controls.js"></script>
	<script src="scenes/Scene1.js"></script>
	<script src="scenes/SceneSponza.js"></script>
	<script src="scenes/Scene3.js"></script>
	<script src="Initialization.js"></script>
	<script>
		init();
		$.getJSON("controls.json", function(json) {
			initControls(json);
		});
		animate();
		
		function refactorShadowMaps() {
			for (var i = 0 ; i < lights.length ; i++)
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			shadowMapAux = new THREE.WebGLRenderTarget(shadowMapsFullResolution, shadowMapsFullResolution, options);
			shadowMapAux2 = new THREE.WebGLRenderTarget(shadowMapsFullResolution, shadowMapsFullResolution, options);
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			ssdoDirectLightingShader.setUniform('shadowMap', 't', shadowMaps[0]);
			ssdoDirectLightingShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			ssdoIndirectBounceShader.setUniform('shadowMap', 't', shadowMaps[0]);
			ssdoIndirectBounceShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag', 'shadowMap1');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag', 'shadowMap2');
			displayManager.organize();
		}
		
		function keyDown(event) {
			//alert(event.keyCode);
			if (event.keyCode == 65) // a
				ANIMATION = !ANIMATION;
			else if (event.keyCode == 79) { // o
				MODE = 'all';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 78) { // n
				MODE = 'normal';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) { // 1 to 9
				displayManager.showViewInGrid(event.keyCode - 97);
			}
			else if (event.keyCode == 80) { // p
				MODE = 'normal';
				displayManager.display({names: ['phong']});
			}
			else if (event.keyCode == 69) { // e
				MODE = 'normal';
				displayManager.display({names: ['expressive']});
			}
			else if (event.keyCode == 83) { // s
				MODE = 'shadows';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 68) { // d
				MODE = 'ssdo';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 84) { // t
				MODE = 'texture';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 82) { // r
				MODE = 'random';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 70) { // f
				MODE = 'dof';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 37) { // left
				if (!displayManager.previousView()) { MODE = 'all'; } render();
			}
			else if (event.keyCode == 39) { // right
				if (!displayManager.nextView()) { MODE = 'all'; } render();
			}
			else if (event.keyCode == 67) { // c
				fizzyText.lightControl = !fizzyText.lightControl;
				if (fizzyText.lightControl)
					initCameraControls(lightsCameras[fizzyText.selectedLight]);
				else
					initCameraControls(camera);
			}
			render();
		}
	
		function render() {
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows' || MODE == 'ssdo' || MODE == 'ssao' || MODE == 'dof') {
				// 1st rendering : computes depth and normals
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(normalsAndDepthShader.getMaterial());
				renderer.render(scene, camera, normalsAndDepthTexture, true);	
			}
			
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows' || MODE == 'ssdo' || MODE == 'ssao' || MODE == 'texture' || MODE == 'dof') {
				// 2nd rendering : diffuse map rendering
				for (var i = 0 ; i < objects.length ; i++) {
					diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					if (objects[i].composedObject) {
						objects[i].setShaderMaterial(diffuseMapShader);
					}
					else {
						if (materials[i]['texture'] != null) {
							diffuseMapShader.setUniform('isTextured', 'i', 1);
							diffuseMapShader.setUniform('diffMap', 't', materials[i]['texture']);
						}
						else {
							diffuseMapShader.setUniform('isTextured', 'i', 0);
							diffuseMapShader.setUniform('diffMap', 't', null);
						}
						objects[i].setMaterial(diffuseMapShader.createMaterial());
					}
				}
				renderer.render(scene, camera, diffuseTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'normal') {
				// 3rd rendering : diffuse rendering with lights
				for (var i = 0 ; i < objects.length ; i++) {
					if (objects[i].composedObject) {
						shaders['diffuse'].use(materials[i]['matDiffuse'], materials[i]['matDiffuseColor'], materials[i]['texture']);
						objects[i].setShaderMaterial(shaders['diffuse']);
					}
					else {
						shaders['diffuse'].use(materials[i]['matDiffuse'], materials[i]['matDiffuseColor'], materials[i]['texture']);
						objects[i].setMaterial(shaders['diffuse'].createMaterial());
					}
				}
				renderer.render(scene, camera, rtTextures['diffuse'], true);
			}
			
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows' || MODE == 'ssdo') {
				// 4th rendering : phong rendering
				for (var i = 0 ; i < objects.length ; i++) {
					if (objects[i].composedObject) {
						shaders['phong'].use(materials[i]['matDiffuse'], materials[i]['matSpecular'], materials[i]['shininess'], materials[i]['matDiffuseColor'], materials[i]['matSpecularColor'], materials[i]['matEmissive'], materials[i]['matEmissiveColor'], materials[i]['texture']);
						objects[i].setShaderMaterial(shaders['phong']);
					}
					else {
						shaders['phong'].use(materials[i]['matDiffuse'], materials[i]['matSpecular'], materials[i]['shininess'], materials[i]['matDiffuseColor'], materials[i]['matSpecularColor'], materials[i]['matEmissive'], materials[i]['matEmissiveColor'], materials[i]['texture']);
						objects[i].setMaterial(shaders['phong'].createMaterial());
					}
				}
				renderer.render(scene, camera, rtTextures['phong'], true);
			}
			
			if (MODE == 'all') { // || MODE == 'normal') {
				// 5th rendering : expressive rendering
				for (var i = 0 ; i < objects.length ; i++) {
					if (objects[i].composedObject) {
						shaders['expressive'].use(materials[i]['matDiffuse'], materials[i]['shininess'], materials[i]['matDiffuseColor']);
						objects[i].setShaderMaterial(shaders['expressive']);
					}
					else {
						shaders['expressive'].use(materials[i]['matDiffuse'], materials[i]['shininess'], materials[i]['matDiffuseColor']);
						objects[i].setMaterial(shaders['expressive'].createMaterial());
					}
				}
				renderer.render(scene, camera, rtTextures['expressive'], true);
			}
			
			if (MODE == 'all' || MODE == 'ssdo' || MODE == 'ssao') {
				// 6th rendering : computes 3D coords
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(coordsShader.getMaterial());
				renderer.render(scene, camera, coordsTexture, true);

				//Second Depth Pass	
				var mat = secondDepthShader.getMaterial();
				mat.side = THREE.DoubleSide;
				for (var i = 0 ; i < objects.length ; i++)
				{
					objects[i].setMaterial(mat);
				}
				renderer.render(scene, camera, secondDepthTexture, true);

			}
			
			if (MODE == 'all' || MODE == 'ssdo' || MODE == 'ssao') {
				//7th rendering : compute second depth	
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(secondDepthShader.getMaterial());
				renderer.render(scene, camera, secondDepthTexture, true);

			}

			if (MODE == 'all' || MODE == 'shadows' || MODE == 'ssdo' || MODE == 'ssao' || MODE == 'dof') {
				// shadow maps
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(shadowMapsShader.getMaterial());
				if (shadowMode == 1 && blurShadowMaps) {
					for (var i = 0 ; i < lights.length ; i++) {
						renderer.render(scene, lightsCameras[i], shadowMapAux, true);
						shadowMapBlurShader.setUniform('shadowMap', 't', shadowMapAux);
						shadowMapBlurShader.setUniform('orientation', 'i', 0);
						smQuad.setMaterial(shadowMapBlurShader.createMaterial());
						renderer.render(smScene, cameraRTT, shadowMapAux2, true);
						shadowMapBlurShader.setUniform('shadowMap', 't', shadowMapAux2);
						shadowMapBlurShader.setUniform('orientation', 'i', 1);
						smQuad.setMaterial(shadowMapBlurShader.createMaterial());
						renderer.render(smScene, cameraRTT, shadowMaps[i], true);
					}
				}
				else {
					renderer.render(scene, lightsCameras[0], shadowMaps[0], true);
					renderer.render(scene, lightsCameras[1], shadowMaps[1], true);
				}
			}
			
			if (MODE == 'all' || MODE == 'shadows' || MODE == 'dof') { // || MODE == 'ssdo') {
				for (var i = 0 ; i < objects.length ; i++) {
					if (objects[i].composedObject) {
						//hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
						hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
						hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
						//hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
						hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
						objects[i].setShaderMaterial(hardShadowsShader);
					}
					else {
						//hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
						hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
						hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
						//hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
						hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
						objects[i].setMaterial(hardShadowsShader.createMaterial());
					}
				}
				renderer.render(scene, camera, hardShadowsTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'dof') {
				// blur
				DOFBlurShader.setUniform('orientation', 'i', 0);
				DOFBlurShader.setUniform('colorTexture', 't', hardShadowsTexture);
				dofQuad.setMaterial(DOFBlurShader.createMaterial());
				renderer.render(dofScene, cameraRTT, dofAuxTexture, true);
			
				DOFBlurShader.setUniform('orientation', 'i', 1);
				DOFBlurShader.setUniform('colorTexture', 't', dofAuxTexture);
				dofQuad.setMaterial(DOFBlurShader.createMaterial());
				renderer.render(dofScene, cameraRTT, DOFBlurTexture, true);
			
				// composited image
				DOFImageShader.setUniform('colorTexture', 't', hardShadowsTexture);
				dofQuad.setMaterial(DOFImageShader.createMaterial());
				renderer.render(dofScene, cameraRTT, DOFImageTexture, true);
			}
			
			// SSAO
			if (MODE == 'all' || MODE == 'ssao') {
				// ssao Only
				ssaoQuad.setMaterial(ssaoOnlyShader.createMaterial());
				renderer.render(ssaoScene, cameraRTT, ssaoOnlyBuffer, true);
			
				// ssao with diffuse color
				ssaoQuad.setMaterial(ssaoDiffuseShader.createMaterial());
				renderer.render(ssaoScene, cameraRTT, ssaoDiffuseBuffer, true);
			}

			// SSDO
			if (MODE == 'all' || MODE == 'ssdo') {
			
				// ssdo 1st pass
				ssdoQuad.setMaterial(ssdoDirectLightingShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, directLightBuffer, true);
				// ssdo 2nd pass
				ssdoQuad.setMaterial(ssdoIndirectBounceShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoIndirectBounceBuffer, true);
			
				// ssdo blur pass
				ssdoBlurShader.setUniform('ssdoBuffer', 't', ssdoIndirectBounceBuffer);
				ssdoBlurShader.setUniform('texelOffset', 'v2', new THREE.Vector2(1.0/window.innerWidth, 0));
				ssdoQuad.setMaterial(ssdoBlurShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoBlurAuxBuffer, true);
			
				ssdoBlurShader.setUniform('ssdoBuffer', 't', ssdoBlurAuxBuffer);
				ssdoBlurShader.setUniform('texelOffset', 'v2', new THREE.Vector2(0.0,1.0/window.innerHeight));
				ssdoQuad.setMaterial(ssdoBlurShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoBlurBuffer, true);
			
				// ssdo final pass
				ssdoQuad.setMaterial(ssdoFinalShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoFinalBuffer, true);

			}
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			if (ANIMATION) {
				if (currentTime - lastTime >= interval) {
					if (objects[0].position.y >= 100)
						direction = -1;
					if (objects[0].position.y <= -50)
						direction = 1;
					objects[0].position.y += direction * 3.0;
					//objects[2].rotation.y += direction * 5 / 100;
					lastTime = currentTime;
					render();
				}
			}
			controls.update(clock.getDelta());
			stats.update();
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
	</script>
</html>

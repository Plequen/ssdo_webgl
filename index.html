<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="Shader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<style>
			body {
				color: #000;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				color: #000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			Mouse left : rotate, middle : zoom, right, right : pan<br/>
			
		</div>
	</body>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth,
			screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 1000;
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, renderer;
		var cross;
		var lights = [], lightPos = [], lightColor = [];
		var objects = [], materials = [];
		//var clock = new THREE.Clock();
		var sceneScreen;
		var rtTexture = [], rttShader = [];
		
		var sphereMesh;
		var phongShader, expressiveShader, zBufferShader;
		var geometryBufferShader, geometryBuffer;
		var normalsAndDepthTexture;
		
		var diffuseMaterialShader;
		var displayManager;
		
		var diffuseMapShader, diffuseTexture;
		
		var ssdoDirectLightingShader, ssdoIndirectBounceShader;
		var directLightBuffer, ssdoFinalBuffer;
		
		init();
		animate();
		
		// process lights for shaders
		function processLights() {
			var lightsNumber = lights.length;
			for (var i = 0 ; i < lights.length ; i++) {
				lightPos[i] = lights[i].getPosition();
				lightColor[i] = lights[i].getColor();
			}
		}
		
		/*function computesUniforms(material) {
			var uniforms = {};
			for (var key in material) {
				uniforms[key] = 
			}
		}*/
		
		// Initialization of the world
		function initScene() {
			scene = new THREE.Scene();
			sceneScreen = new THREE.Scene();
			//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
			
			// lights
			lights[0] = new Light(
				new THREE.Vector3(300, 50, 200),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0)
			);
			lights[1] = new Light(
				new THREE.Vector3(-300, 50, 200),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0)
			);
			processLights();
			
			// shaders
			phongShader = new Shader();
			phongShader.setUniform('lightPos', 'v3v', lightPos);
			phongShader.setUniform('lightColor', 'v4v', lightColor);
			phongShader.setAttribute('displacement', 'f', []);
			phongShader.loadShader('shaders/default.vert', 'vertex');
			phongShader.loadShader('shaders/phong.frag', 'fragment');
			
			expressiveShader = new Shader();
			expressiveShader.setUniform('lightPos', 'v3v', lightPos);
			expressiveShader.setUniform('lightColor', 'v4v', lightColor);
			expressiveShader.setShader(phongShader.getShader('vertex'), 'vertex');
			expressiveShader.loadShader('shaders/expressive.frag', 'fragment');
			
			//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
			
			var options = {
				minFilter: THREE.LinearFilter,
				magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				//type: THREE.FloatType
			};
			
			/*geometryBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			geometryBufferShader = new Shader();
			//geometryBufferShader.addUniform('zBuffer', 't', geometryBuffer);
			//geometryBufferShader.addAttribute('test', 'f', 0.0);
			geometryBufferShader.loadShader('geometryBufferShader.vert', 'vertex');
			geometryBufferShader.loadShader('geometryBufferShader.frag', 'fragment');*/
			
			normalsAndDepthTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			normalsAndDepthShader = new Shader();
			normalsAndDepthShader.loadShader('shaders/default.vert', 'vertex');
			normalsAndDepthShader.loadShader('shaders/computesNormalsDepth.frag', 'fragment');
			
			diffuseMaterialShader = new Shader();
			diffuseMaterialShader.setUniform('lightPos', 'v3v', lightPos);
			diffuseMaterialShader.setUniform('lightColor', 'v4v', lightColor);
			diffuseMaterialShader.loadShader('shaders/default.vert', 'vertex');
			diffuseMaterialShader.loadShader('shaders/diffuseMaterial.frag', 'fragment');
			
			diffuseMapShader = new Shader();
			diffuseMapShader.loadShader('shaders/default.vert', 'vertex');
			diffuseMapShader.loadShader('shaders/diffuseMap.frag', 'fragment');
			
			ssdoDirectLightingShader = new Shader();
			ssdoDirectLightingShader.loadShader('shaders/texture.vert', 'vertex');
			ssdoDirectLightingShader.loadShader('shaders/SSDODirectLightingShader.frag', 'fragment');
			
			ssdoDirectLightingShader = new Shader();
			//ssdoDirectLightingShader
			ssdoDirectLightingShader.loadShader('shaders/texture.vert', 'vertex');
			ssdoDirectLightingShader.loadShader('shaders/SSDODirectLighting.frag', 'fragment');
			
			ssdoIndirectBounceShader = new Shader();
			ssdoIndirectBounceShader.loadShader('shaders/texture.vert', 'vertex');
			ssdoIndirectBounceShader.loadShader('shaders/SSDOIndirectBounce.frag', 'fragment');
			ssdoIndirectBounceShader.setUniform('directLightBuffer', 't', directLightBuffer);
			
			// sphere
			var sphereMaterial = new THREE.MeshLambertMaterial({
				color: 0xCC0000
			});
			var radius = 50, segments = 16, rings = 16;
			
			var sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
			objects[0] = new THREE.Mesh(sphereGeometry);
			materials[0] = [];
			materials[0]['matDiffuse'] = 0.8;
			materials[0]['matSpecular'] = 0.8;
			materials[0]['matEmissive'] = 0.0;
			materials[0]['shininess'] = 5.0;
			materials[0]['matDiffuseColor'] = new THREE.Vector4(1.0, 0.0, 0.0, 1.0);
			materials[0]['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
			materials[0]['matEmissiveColor'] = new THREE.Vector4(0.0, 1.0, 0.0, 1.0);
			scene.add(objects[0]);
			
			var geometry = new THREE.CylinderGeometry(0, 10, 30, 4, 1);
			objects[1] = new THREE.Mesh(geometry);
			objects[1].position.x = -100;
			objects[1].position.z = -100;
			materials[1] = materials[0];
			scene.add(objects[1]);
			
			// off importation
			loadOFF('models/monkey.off');
			objects[2].position.x = 150;
			materials[2] = [];
			materials[2]['matDiffuse'] = 0.8;
			materials[2]['matSpecular'] = 0.3;
			materials[2]['matEmissive'] = 0.0;
			materials[2]['shininess'] = 5.0;
			materials[2]['matDiffuseColor'] = new THREE.Vector4(0.2, 1.0, 0.2, 1.0);
			materials[2]['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
			materials[2]['matEmissiveColor'] = new THREE.Vector4(0.0, 1.0, 0.0, 1.0);
			scene.add(objects[2]);
			
			loadOFF('models/ram.off');
			objects[3].position.x = -80;
			objects[3].position.z = 100;
			objects[3].position.y = -50;
			objects[3].rotation.x = - Math.PI / 2;
			materials[3] = jQuery.extend(true, {}, materials[2]);
			materials[3]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.0, 0.5, 1.0);
			scene.add(objects[3]);
			// now populate the array of attributes
			/*var vertices = sphere.geometry.vertices;
			var values = attributes.displacement.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 30);
			}*/
			

			// displays for the different renderings
			var options2 = {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat};
			rtTexture[0] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			rtTexture[1] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			rtTexture[2] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			diffuseTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			directLightBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			ssdoFinalBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options2);
			
			displayManager = new DisplayManager(sceneScreen, {type: 'GRID', cols: 3, rows: 3});
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepth.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayNormals.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepthNormals.frag');
			displayManager.addSimpleTexture(rtTexture[0]);
			displayManager.addSimpleTexture(rtTexture[1]);
			displayManager.addSimpleTexture(rtTexture[2]);
			displayManager.addSimpleTexture(diffuseTexture);
			displayManager.addSimpleTexture(directLightBuffer);
			displayManager.addSimpleTexture(ssdoFinalBuffer);
			displayManager.organize();
			
			var plane = new THREE.PlaneGeometry(window.innerWidth / 2, window.innerHeight / 2);
			
			/*var plane0 = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
			var rttS = new Shader();
			rttS.addUniform('texture', 't', normalsAndDepthTexture);
			rttS.loadShader('processingTextureShader.vert', 'vertex');
			rttS.loadShader('processingTextureShader.frag', 'fragment');
			var quad0 = new THREE.Mesh(plane0, rttS.getMaterial());
			quad0.position.z = 0;
			sceneScreen.add(quad0);*/
		}
		
		// Initialization
		function init() {
			// camera
			camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
			camera.position.z = 300;
			
			cameraRTT = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000);
			cameraRTT.position.z = 100;
			
			// controls
			controls = new THREE.TrackballControls(camera);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];
			controls.addEventListener('change', render);
			
			// world
			initScene();
			
			// renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xFFFFFF, 1);
			renderer.setSize(screenWidth, screenHeight);

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			
			// display
			$container = $('#container');
			$container.append(renderer.domElement);
			$container.append(stats.domElement);
			
			window.addEventListener('resize', onWindowResize, false);
			window.addEventListener('keydown', keyDown, false);
		}
		
		function keyDown(event) {
			if (event.keyCode == 96) {
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 3});
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) {
				displayManager.changeMode({type: 'SINGLE', id: (event.keyCode - 97)});
			}
			render();
		}
	
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			if (currentTime - lastTime >= interval) {
				/*if (sphereMesh.position.z >= 0)
					direction = -1;
				if (sphereMesh.position.z <= -400)
					direction = 1;
				sphereMesh.position.z += direction * 10;*/
				lastTime = currentTime;
				//render();
			}
			controls.update();
			stats.update();
		}
		
		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function render() {
			// 1st rendering : computes depth and normals
			for (var i = 0 ; i < objects.length ; i++)
				objects[i].setMaterial(normalsAndDepthShader.getMaterial());
			renderer.render(scene, camera, normalsAndDepthTexture, true);
			
			// 2nd rendering : complete rendering
			for (var i = 0 ; i < objects.length ; i++) {
				phongShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				phongShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
				phongShader.setUniform('matEmissive', 'f', materials[i]['matEmissive']);
				phongShader.setUniform('shininess', 'f', materials[i]['shininess']);
				phongShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				phongShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
				phongShader.setUniform('matEmissiveColor', 'v4', materials[i]['matEmissiveColor']);
				objects[i].setMaterial(phongShader.createMaterial());
			}
			renderer.render(scene, camera, rtTexture[0], true);
			
			// 3rd rendering : expressive rendering for the sphere
			expressiveShader.setUniform('matDiffuse', 'f', materials[0]['matDiffuse']);
			expressiveShader.setUniform('shininess', 'f', materials[0]['shininess']);
			expressiveShader.setUniform('matDiffuseColor', 'v4', materials[0]['matDiffuseColor']);
			objects[0].setMaterial(expressiveShader.getMaterial());
			renderer.render(scene, camera, rtTexture[1], true);
			
			// 4th rendering : diffuse material rendering
			for (var i = 0 ; i < objects.length ; i++) {
				diffuseMaterialShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				diffuseMaterialShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(diffuseMaterialShader.createMaterial());
			}
			renderer.render(scene, camera, rtTexture[2], true);
			
			// 5th rendering : diffuse map rendering
			for (var i = 0 ; i < objects.length ; i++) {
				diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(diffuseMapShader.createMaterial());
			}
			renderer.render(scene, camera, diffuseTexture, true);
			
///////////////
			// ssdo 1st pass
			for (var i = 0 ; i < objects.length ; i++) {
				ssdoDirectLightingShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				ssdoDirectLightingShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(ssdoDirectLightingShader.createMaterial());
			}
			renderer.render(scene, camera, directLightBuffer, true);
			
			// ssdo 2nd pass
			for (var i = 0 ; i < objects.length ; i++) {
				ssdoIndirectBounceShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
				ssdoIndirectBounceShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
				objects[i].setMaterial(ssdoIndirectBounceShader.createMaterial());
			}
			renderer.render(scene, camera, ssdoFinalBuffer, true);
			
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		function loadOFF(fileName) {
			$.ajax({
				url: fileName,
				async: false,
				dataType: 'text',
				context: {
				},
				complete: processOFF
			});
		}
		
		function processOFF(jqXHR, textStatus) {
			var geometry = new THREE.Geometry();
			var lines = jqXHR.responseText.split("\n");
			if (lines[0] != "OFF")
					alert('Not an OFF file');
			else {
				var scale = 50;
				var params = lines[1].split(" ");
				// params[0] : number of vertices
				// params[1] : number of triangles
				// params[2] : number of what
				/*alert("lines : " + lines.length + "\n" +
					"vertices : " + params[0] + "\n" + 
					"faces : " + params[1] + "\n" + 
					"what : " + params[2]);*/
				for (var i = 0 ; i < params[0] ; i++) {
					var coords = lines[2 + i].split(" ");
					geometry.vertices.push(new THREE.Vector3(scale * coords[0], scale * coords[1], scale * coords[2]));
				}
				for (var i = 0 ; i < params[1] ; i++) {
					var indexes = lines[2 + parseInt(params[0]) + i].split(" ");
					// [0] : polygon size
					geometry.faces.push(new THREE.Face3(indexes[1], indexes[2], indexes[3]));
				}
				geometry.computeFaceNormals();
				
				var objectID = objects.length;
				objects[objectID] = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial());
				scene.add(objects[objectID]);
			}
		}
	</script>
</html>
<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="OFF.js"></script>
		<script src="Shader.js"></script>
		<script src="PhongShader.js"></script>
		<script src="ExpressiveShader.js"></script>
		<script src="DiffuseShader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<link rel="stylesheet" href="css/main.css" />  
	</head>
	<body>
		<div id="container"></div>
	</body>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 10000;
			
		var lightDefaultAngle = 60.0, skyLightIntensity = 0.1, 
			lightDefaultAttenuation = 0.4, lightDefaultIntensity = 1.0;
		var cameraSpeed = 10.0;
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, sceneScreen, renderer, displayManager;
		var lights = [], lightsPos = [], lightsColor = [], lightsIntensity = [];
		var lightsAngle = [], lightsAttenuation = [];
		var lightsCameras = [], lightsView = [], lightsProj = [], lightsRot = [];
		var objects = [], materials = [];
		var blankMaterial = []; blankMaterial['matDiffuse'] = 0.8; blankMaterial['matSpecular'] = 0.3;
		blankMaterial['matEmissive'] = 0.0; blankMaterial['shininess'] = 5.0;
		blankMaterial['matDiffuseColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matEmissiveColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		
		var shaders = [], rtTextures = [];
		var normalsAndDepthShader, normalsAndDepthTexture;
		var diffuseMapShader, diffuseTexture;
		var coordsShader, coordsTexture;
		
		var shadowMaps = [], shadowMapsResolution = 64;
		var hardShadowsShader, hardShadowsTexture;
		
		var ssdoScene, ssdoQuad;
		var ssdoDirectLightingShader, directLightBuffer;
		var ssdoIndirectBounceShader, ssdoFinalBuffer;
		
		var customDisplays = [];
		customDisplays['normal'] = {cols: 2	, rows: 3, names: ['depth', 'normals', 'depthAndNormals', 'diffuse', 'phong', 'expressive']};
		customDisplays['all'] = {cols: 4, rows: 3, all: true};
		customDisplays['shadows'] = {cols: 2, rows: 2, 
			names: ['shadowMap1', 'shadowMap2', 'hardShadows']};
		customDisplays['ssdo'] = {cols: 2, rows: 1, 
			names: ['ssdoDirect', 'ssdoFinal']};
		
		var MODE = 'shadows', ANIMATION = false;
		
		//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
		var options = {
				minFilter: THREE.LinearFilter,
				//magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				type: THREE.FloatType
			};
			
	</script>
	<script src="Controls.js"></script>
	<script src="Initialization.js"></script>
	<script>
		init();
		initControls();
		animate();
		
		function refactorShadowMaps() {
			for (var i = 0 ; i < lights.length ; i++)
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
<<<<<<< HEAD
			hardShadowsShader.setUniform('lightsView', 'm4v', lightsView);
			hardShadowsShader.setUniform('lightsProj', 'm4v', lightsProj);
			hardShadowsShader.setUniform('lightsRot', 'm3v', lightsRot);
			hardShadowsShader.setUniform('lightsPos', 'v3v', lightsPos);
			hardShadowsShader.setUniform('lightsColor', 'v4v', lightsColor);
			hardShadowsShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			hardShadowsShader.setUniform('lightsAngle', 'fv1', lightsAngle);
			hardShadowsShader.setUniform('skyLightIntensity', 'f', skyLightIntensity);
			hardShadowsShader.setUniform('PI', 'f', Math.PI);
			//hardShadowsShader.setUniform('worldMatrix', 'm4', camera.matrixWorldInverse);
			
			// SSDO shaders
			directLightBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			ssdoDirectLightingShader = new Shader();
			ssdoDirectLightingShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoDirectLightingShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoDirectLightingShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoDirectLightingShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoDirectLightingShader.loadShader('shaders/SSDODirectLighting.frag', 'fragment');
			ssdoDirectLightingShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoDirectLightingShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoDirectLightingShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoDirectLightingShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoDirectLightingShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoDirectLightingShader.setUniform('cameraProjectionM', 'm4', camera.projectionMatrix);
			ssdoDirectLightingShader.setUniform('cameraViewMatrix', 'm4', camera.matrixWorldInverse);
			//ssdoDirectLightingShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoIndirectBounceShader = new Shader();
			ssdoIndirectBounceShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoIndirectBounceShader.loadShader('shaders/SSDOIndirectBounce.frag', 'fragment');
			ssdoIndirectBounceShader.setUniform('directLightBuffer', 't', directLightBuffer);
			ssdoIndirectBounceShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoIndirectBounceShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoIndirectBounceShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoIndirectBounceShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoIndirectBounceShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoIndirectBounceShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoIndirectBounceShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoIndirectBounceShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoIndirectBounceShader.setUniform('projectionM', 'mat4', camera.projectionMatrix);
			//ssdoIndirectBounceShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoScene = new THREE.Scene();
			var plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
			ssdoQuad = new THREE.Mesh(plane);
			ssdoScene.add(ssdoQuad);
			
			// sphere
			var sphereMaterial = new THREE.MeshLambertMaterial({color: 0xCC0000});
			var radius = 50, segments = 16, rings = 16;
			var sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
			objects[0] = new THREE.Mesh(sphereGeometry);
			materials[0] = jQuery.extend(true, {}, blankMaterial);
			materials[0]['matSpecular'] = 0.8;
			materials[0]['matDiffuseColor'] = new THREE.Vector4(1.0, 0.0, 0.0, 1.0);
			scene.add(objects[0]);
			//objects[0].add(camera);
			
			var geometry = new THREE.CylinderGeometry(0, 10, 30, 4, 1);
			objects[1] = new THREE.Mesh(geometry);
			objects[1].position.x = -100;
			objects[1].position.z = -100;
			objects[1].position.y = -50;
			materials[1] = materials[0];
			scene.add(objects[1]);
			
			// off importation
			loadOFF('models/monkey.off');
			objects[2].position.x = 150;
			materials[2] = jQuery.extend(true, {}, blankMaterial);
			materials[2]['matDiffuseColor'] = new THREE.Vector4(0.2, 1.0, 0.2, 1.0);
			scene.add(objects[2]);
			
			loadOFF('models/ram.off');
			objects[3].position.x = -80;
			objects[3].position.z = 100;
			objects[3].position.y = -50;
			objects[3].rotation.x = - Math.PI / 2;
			materials[3] = jQuery.extend(true, {}, blankMaterial);
			materials[3]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.0, 0.5, 1.0);
			scene.add(objects[3]);
			
			loadOFF('models/ground.off', 200);
			objects[4].position.y = -100;
			objects[4].rotation.x = - Math.PI / 2;
			materials[4] = jQuery.extend(true, {}, blankMaterial);
			materials[4]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.5, 0.5, 1.0);
			scene.add(objects[4]);
			
			//phongShader.setAttribute('displacement', 'f', []);
			// now populate the array of attributes
			/*var vertices = sphere.geometry.vertices;
			var values = attributes.displacement.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 30);
			}*/
			
			// displays for the different renderings
			displayManager = new DisplayManager(sceneScreen, {type: 'GRID', cols: 2, rows: 3});
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepth.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayNormals.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepthNormals.frag');
			displayManager.addSimpleTexture(rtTextures['phong'], 'phong');
			displayManager.addSimpleTexture(rtTextures['expressive'], 'expressive');
			displayManager.addSimpleTexture(rtTextures['diffuse']);
			displayManager.addSimpleTexture(diffuseTexture);
=======
>>>>>>> 97a696c8f7679223de31b1ddc3275a585c856989
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag', 'shadowMap1');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag', 'shadowMap2');
			displayManager.organize();
		}
		
		function keyDown(event) {
			if (event.keyCode == 65) // a
				ANIMATION = !ANIMATION;
			else if (event.keyCode == 79) { // o
				MODE = 'all';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 78) { // n
				MODE = 'normal';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) { // 1 to 9
				/*if (MODE == 'normal')
					displayManager.changeMode({type: 'SINGLE', id: (event.keyCode - 97)});
				else if (MODE == 'shadows')
					displayManager.changeMode({type: 'SINGLE', name: shadowGrid[event.keyCode - 97]});
				else if (MODE == 'ssdo')
					displayManager.changeMode({type: 'SINGLE', name: ssdoGrid[event.keyCode - 97]});
				*/
			}
			else if (event.keyCode == 80) { // p
				MODE = 'normal';
				displayManager.display({names: ['phong']});
			}
			else if (event.keyCode == 69) { // e
				MODE = 'normal';
				displayManager.display({names: ['expressive']});
			}
			else if (event.keyCode == 83) { // s
				MODE = 'shadows';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 68) { // d
				MODE = 'ssdo';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 38) { // up
				var pLocal = new THREE.Vector3(0, 0, -1);
				var pWorld = pLocal.applyMatrix4(camera.matrixWorld);
				var dir = pWorld.sub(camera.position).normalize();
				camera.position.x += cameraSpeed * dir.x;
				camera.position.y += cameraSpeed * dir.y;
				camera.position.z += cameraSpeed * dir.z;
			}
			else if (event.keyCode == 38) { // up
				var pLocal = new THREE.Vector3(0, 0, -1);
				var pWorld = pLocal.applyMatrix4(camera.matrixWorld);
				var dir = pWorld.sub(camera.position).normalize();
				camera.position.x += cameraSpeed * dir.x;
				camera.position.y += cameraSpeed * dir.y;
				camera.position.z += cameraSpeed * dir.z;
			}
			render();
		}
	
		function render() {
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows' || MODE == 'ssdo') {
				// 1st rendering : computes depth and normals
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(normalsAndDepthShader.getMaterial());
				renderer.render(scene, camera, normalsAndDepthTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'normal') {
				// 2nd rendering : complete rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['phong'].use(materials[i]['matDiffuse'], materials[i]['matSpecular'], materials[i]['shininess'], materials[i]['matDiffuseColor'], materials[i]['matSpecularColor'], materials[i]['matEmissive'], materials[i]['matEmissiveColor']);
					objects[i].setMaterial(shaders['phong'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['phong'], true);
				
				// 3rd rendering : expressive rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['expressive'].use(materials[i]['matDiffuse'], materials[i]['shininess'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['expressive'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['expressive'], true);
			
				// 4th rendering : diffuse material rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['diffuse'].use(materials[i]['matDiffuse'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['diffuse'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['diffuse'], true);
			}
			
			if (MODE == 'all' || MODE == 'ssdo') {
				// 5th rendering : diffuse map rendering
				for (var i = 0 ; i < objects.length ; i++) {
					diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					objects[i].setMaterial(diffuseMapShader.createMaterial());
				}
				renderer.render(scene, camera, diffuseTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'shadows') {
				// shadow maps
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(shadowMapsShader.getMaterial());
				renderer.render(scene, lightsCameras[0], shadowMaps[0], true);
				renderer.render(scene, lightsCameras[1], shadowMaps[1], true);
				
				for (var i = 0 ; i < objects.length ; i++) {
					hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
					hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
					hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
					objects[i].setMaterial(hardShadowsShader.createMaterial());
				}
				renderer.render(scene, camera, hardShadowsTexture, true);
			}
			
			// SSDO
			if (MODE == 'all' || MODE == 'ssdo') {
				// computes 3D coords
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(coordsShader.getMaterial());
				renderer.render(scene, camera, coordsTexture, true);
				
				// ssdo 1st pass
				ssdoQuad.setMaterial(ssdoDirectLightingShader.getMaterial());
				renderer.render(ssdoScene, cameraRTT, directLightBuffer, true);
				// ssdo 2nd pass
				ssdoQuad.setMaterial(ssdoIndirectBounceShader.getMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoFinalBuffer, true);
			}
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			if (ANIMATION) {
				if (currentTime - lastTime >= interval) {
					if (objects[0].position.y >= 100)
						direction = -1;
					if (objects[0].position.y <= -50)
						direction = 1;
					objects[0].position.y += direction * 5;
					lastTime = currentTime;
					render();
				}
			}
			controls.update();
			stats.update();
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
	</script>
</html>

<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/MTLLoaderP.js"></script>
		<script src="lib/OBJMTLLoader.js"></script>
		<script src="OFF.js"></script>
		<script src="Shader.js"></script>
		<script src="PhongShader.js"></script>
		<script src="ExpressiveShader.js"></script>
		<script src="DiffuseShader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<link rel="stylesheet" href="css/main.css" />  
	</head>
	<body>
		<div id="container"></div>
	</body>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 10000;
			
		var lightDefaultAngle = 60.0, skyLightIntensity = 0.1, 
			lightDefaultAttenuation = 0.4, lightDefaultIntensity = 1.0;
		var cameraSpeed = 10.0;
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, sceneScreen, renderer, displayManager;
		var lights = [], lightsPos = [], lightsColor = [], lightsIntensity = [];
		var lightsAngle = [], lightsAttenuation = [];
		var lightsCameras = [], lightsView = [], lightsProj = [];
		var objects = [], materials = [];
		var blankMaterial = []; blankMaterial['matDiffuse'] = 0.8; blankMaterial['matSpecular'] = 0.3;
		blankMaterial['matEmissive'] = 0.0; blankMaterial['shininess'] = 5.0;
		blankMaterial['matDiffuseColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matEmissiveColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['texture'] = null;
		
		var shaders = [], rtTextures = [];
		var normalsAndDepthShader, normalsAndDepthTexture;
		var diffuseMapShader, diffuseTexture;
		var materialShader, materialTexture;
		var coordsShader, coordsTexture;
		var texturedPhong, texturedPhongTexture;
		
		var shadowMaps = [], shadowMapsResolution = 64;
		var hardShadowsShader, hardShadowsTexture;
		
		var ssdoScene, ssdoQuad;
		var ssdoDirectLightingShader, directLightBuffer;
		var ssdoIndirectBounceShader, ssdoFinalBuffer;
		
		var customDisplays = [];
		customDisplays['normal'] = {cols: 2	, rows: 3, names: ['depth', 'normals', 'depthAndNormals', 'diffuse', 'phong', 'expressive']};
		customDisplays['all'] = {cols: 4, rows: 3, all: true};
		customDisplays['shadows'] = {cols: 2, rows: 2, 
			names: ['shadowMap1', 'shadowMap2', 'hardShadows', 'phong']};
		customDisplays['ssdo'] = {cols: 2, rows: 2, 
			names: ['shadowMap1', 'texturedPhong', 'ssdoDirect', 'ssdoFinal']};
		customDisplays['textured'] = {names: ['diffuseMap']};
		customDisplays['material'] = {names: ['material']};
		
		var MODE = 'material', ANIMATION = false;
		
		//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
		var options = {
				minFilter: THREE.LinearFilter,
				//magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				type: THREE.FloatType
			};
		var blankTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
		var testTexture = THREE.ImageUtils.loadTexture('textures/avatar.jpg');
	</script>
	<script src="Controls.js"></script>
	<script src="Scene1.js"></script>
	<script src="Scene2.js"></script>
	<script src="Initialization.js"></script>
	<script>
		init();
		initControls();
		animate();
		
		function refactorShadowMaps() {
			for (var i = 0 ; i < lights.length ; i++)
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag', 'shadowMap1');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag', 'shadowMap2');
			displayManager.organize();
		}
		
		function keyDown(event) {
			//alert(event.keyCode);
			if (event.keyCode == 65) // a
				ANIMATION = !ANIMATION;
			else if (event.keyCode == 79) { // o
				MODE = 'all';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 78) { // n
				MODE = 'normal';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) { // 1 to 9
				/*if (MODE == 'normal')
					displayManager.changeMode({type: 'SINGLE', id: (event.keyCode - 97)});
				else if (MODE == 'shadows')
					displayManager.changeMode({type: 'SINGLE', name: shadowGrid[event.keyCode - 97]});
				else if (MODE == 'ssdo')
					displayManager.changeMode({type: 'SINGLE', name: ssdoGrid[event.keyCode - 97]});
				*/
			}
			else if (event.keyCode == 80) { // p
				MODE = 'normal';
				displayManager.display({names: ['phong']});
			}
			else if (event.keyCode == 69) { // e
				MODE = 'normal';
				displayManager.display({names: ['expressive']});
			}
			else if (event.keyCode == 83) { // s
				MODE = 'shadows';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 68) { // d
				MODE = 'ssdo';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 84) { // t
				MODE = 'textured';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 77) { // t
				MODE = 'material';
				displayManager.display(customDisplays[MODE]);
			}
			else if (event.keyCode == 38) { // up
				var pLocal = new THREE.Vector3(0, 0, -1);
				var pWorld = pLocal.applyMatrix4(camera.matrixWorld);
				var dir = pWorld.sub(camera.position).normalize();
				camera.position.x += cameraSpeed * dir.x;
				camera.position.y += cameraSpeed * dir.y;
				camera.position.z += cameraSpeed * dir.z;
			}
			else if (event.keyCode == 38) { // up
				var pLocal = new THREE.Vector3(0, 0, -1);
				var pWorld = pLocal.applyMatrix4(camera.matrixWorld);
				var dir = pWorld.sub(camera.position).normalize();
				camera.position.x += cameraSpeed * dir.x;
				camera.position.y += cameraSpeed * dir.y;
				camera.position.z += cameraSpeed * dir.z;
			}
			render();
		}
	
		function render() {
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows' || MODE == 'ssdo') {
				// 1st rendering : computes depth and normals
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(normalsAndDepthShader.getMaterial());
				renderer.render(scene, camera, normalsAndDepthTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'normal' || MODE == 'shadows') {
				// 2nd rendering : phong rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['phong'].use(materials[i]['matDiffuse'], materials[i]['matSpecular'], materials[i]['shininess'], materials[i]['matDiffuseColor'], materials[i]['matSpecularColor'], materials[i]['matEmissive'], materials[i]['matEmissiveColor']);
					objects[i].setMaterial(shaders['phong'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['phong'], true);
				
				// 3rd rendering : expressive rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['expressive'].use(materials[i]['matDiffuse'], materials[i]['shininess'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['expressive'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['expressive'], true);
			
				// 4th rendering : diffuse material rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['diffuse'].use(materials[i]['matDiffuse'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['diffuse'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['diffuse'], true);
			}
			
			if (MODE == 'all' || MODE == 'ssdo' || MODE == 'textured') {
				// 5th rendering : diffuse map rendering
				for (var i = 0 ; i < objects.length ; i++) {
					diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					if (materials[i]['texture'] != null) {
						diffuseMapShader.setUniform('isTextured', 'i', 1);
						diffuseMapShader.setUniform('texture', 't', materials[i]['texture']);
					}
					else {
						diffuseMapShader.setUniform('isTextured', 'i', 0);
						diffuseMapShader.setUniform('texture', 't', null);
					}
					if (objects[i].setComposedMaterial == null)
						objects[i].setMaterial(diffuseMapShader.createMaterial());
					else
						objects[i].setComposedMaterial(diffuseMapShader);
				}
				renderer.render(scene, camera, diffuseTexture, true);
			}
			
			if (MODE == 'material' || MODE == 'ssdo') {
				for (var i = 0 ; i < objects.length ; i++) {
					if (objects[i].setComposedMaterial == null) {
						materialShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
						materialShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);	
					
						if (materials[i]['texture'] != null) {
							materialShader.setUniform('isTextured', 'i', 1);
							materialShader.setUniform('texture', 't', materials[i]['texture']);
						}
						else {
							materialShader.setUniform('isTextured', 'i', 0);
							materialShader.setUniform('texture', 't', null);
						}
						objects[i].setMaterial(materialShader.createMaterial());
					}
					else
						objects[i].setComposedMaterial(materialShader);
				}
				renderer.render(scene, camera, materialTexture, true);
			}
			
			if (MODE == 'all' || MODE == 'shadows' || MODE == 'ssdo') {
				// shadow maps
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(shadowMapsShader.getMaterial());
				renderer.render(scene, lightsCameras[0], shadowMaps[0], true);
				renderer.render(scene, lightsCameras[1], shadowMaps[1], true);
			}
			
			if (MODE == 'all' || MODE == 'shadows' || MODE == 'ssdo') {
				for (var i = 0 ; i < objects.length ; i++) {
					hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
					hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
					hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
					objects[i].setMaterial(hardShadowsShader.createMaterial());
				}
				renderer.render(scene, camera, hardShadowsTexture, true);
			}
			
			// SSDO
			if (MODE == 'all' || MODE == 'ssdo') {
				for (var i = 0 ; i < objects.length ; i++) {
					texturedPhong.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
					texturedPhong.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
					texturedPhong.setUniform('shininess', 'f', materials[i]['shininess']);
					objects[i].setMaterial(texturedPhong.createMaterial());
				}
				renderer.render(scene, camera, texturedPhongTexture, true);
				
				// computes 3D coords
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(coordsShader.getMaterial());
				renderer.render(scene, camera, coordsTexture, true);
				
				// ssdo 1st pass
				ssdoQuad.setMaterial(ssdoDirectLightingShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, directLightBuffer, true);
				// ssdo 2nd pass
				ssdoQuad.setMaterial(ssdoIndirectBounceShader.createMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoFinalBuffer, true);
			}
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			if (ANIMATION) {
				if (currentTime - lastTime >= interval) {
					if (objects[0].position.y >= 100)
						direction = -1;
					if (objects[0].position.y <= -50)
						direction = 1;
					objects[0].position.y += direction * 3.0;
					//objects[2].rotation.y += direction * 5 / 100;
					lastTime = currentTime;
					render();
				}
			}
			controls.update();
			stats.update();
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
	</script>
</html>

<!DOCTYPE html>
<html>
	<head>
		<title>WebGL SSDO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/prototype.js"></script>
		<script src="lib/jquery-1.9.1.min.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="OFF.js"></script>
		<script src="Shader.js"></script>
		<script src="PhongShader.js"></script>
		<script src="ExpressiveShader.js"></script>
		<script src="DiffuseShader.js"></script>
		<script src="Light.js"></script>
		<script src="DisplayManager.js"></script>
		<style>
			body {
				color: #000;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				color: #000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
	</body>
	<script>
		
	</script>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();
		
		// Screen
		var screenWidth = window.innerWidth, screenHeight = window.innerHeight;
		// Camera
		var	viewAngle = 45,
			aspect = screenWidth / screenHeight,
			near = 0.1,
			far = 10000;
			
		var lightDefaultAngle = 60.0, skyLightIntensity = 0.1, 
			lightDefaultAttenuation = 0.4, lightDefaultIntensity = 1.0;
		
		var $container, stats;
		var camera, cameraRTT, controls, scene, sceneScreen, renderer, displayManager;
		var lights = [], lightsPos = [], lightsColor = [], lightsIntensity = [];
		var lightsAngle = [], lightsAttenuation = [];
		var lightsCameras = [], lightsView = [], lightsProj = [], lightsRot = [];
		var objects = [], materials = [];
		var blankMaterial = []; blankMaterial['matDiffuse'] = 0.8; blankMaterial['matSpecular'] = 0.3;
		blankMaterial['matEmissive'] = 0.0; blankMaterial['shininess'] = 5.0;
		blankMaterial['matDiffuseColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matSpecularColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		blankMaterial['matEmissiveColor'] = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);
		
		var shaders = [], rtTextures = [];
		var normalsAndDepthShader, normalsAndDepthTexture;
		var diffuseMapShader, diffuseTexture;
		var coordsShader, coordsTexture;
		
		var shadowMaps = [], shadowMapsResolution = 64;
		var hardShadowsShader, hardShadowsTexture;
		var shadowGrid = ['shadowMap1', 'shadowMap2', 'hardShadows'];
		
		var ssdoScene, ssdoQuad;
		var ssdoDirectLightingShader, directLightBuffer;
		var ssdoIndirectBounceShader, ssdoFinalBuffer;
		var ssdoGrid = ['ssdoDirect', 'ssdoFinal'];
		
		var MODE = 'SHADOWS', ANIMATION = false;
		
		//minFilter: THREE.LinearMipmapLinearFilter,  // we want mipmaps
			//magFilter: THREE.LinearFilter,  // we want nice filtering
			//wrapS:THREE.RepeatWrapping,
			//wrapT:THREE.RepeatWrapping,
		var options = {
				minFilter: THREE.LinearFilter,
				//magFilter: THREE.NearestFilter,
				format: THREE.RGBAFormat,
				type: THREE.FloatType
			};
			
		var FizzyText = function() {
			this.message = 'dat.gui';
			this.speed = 0.5;
			this.displayOutline = false;
			this.noiseStrength = 10;
			this.growthSpeed = 0.1;
			this.explode = function() { alert("ok"); };
			this.mapsResolution = shadowMapsResolution;
			this.gridDisplayed = 'overview';
			this.viewDisplayed = 'phong';
			this.nextView = function() { displayManager.nextView(); render(); };
			this.previousView = function() { displayManager.previousView(); render(); };
			this.allLights = false;
			this.selectedLight = 0;
			this.lightColor = "#ffffff";
			this.lightIntensity = lightDefaultIntensity;
			this.lightAngle = lightDefaultAngle;
			this.skyLightIntensity = skyLightIntensity;
			this.lightAttenuation = lightDefaultAttenuation;
		};
		
		function initControls() {
			var text = new FizzyText();
			var gui = new dat.GUI();
			//gui.remember(text);
			
			gui.add(text, 'message');
			gui.add(text, 'displayOutline');
			gui.add(text, 'explode');
			
			var displaysFolder = gui.addFolder('Views');
			displaysFolder.add(text, 'gridDisplayed', {'Overview': 'overview', 'Shadows': 'shadows', 'SSDO': 'ssdo'}).name('Grid');
			displaysFolder.add(text, 'viewDisplayed', {'Phong': 'phong', 'Expressive': 'expressive', 'Hard shadows': 'hardShadows'}).name('View');
			displaysFolder.add(text, 'nextView').name('Next view');
			displaysFolder.add(text, 'previousView').name('Previous view');
			displaysFolder.open();
			
			var lightsFolder = gui.addFolder('Lights');
			lightsFolder.add(text, 'skyLightIntensity', 0, 1).step(0.05).name('Sky light').onChange(function(value) {
				skyLightIntensity = value;
				hardShadowsShader.setUniform('skyLightIntensity', 'f', skyLightIntensity);
				render();
			});
			lightsFolder.add(text, 'allLights').name('All');
			var lightsToSelect = {};
			for (var i = 0 ; i < lights.length ; i++)
				lightsToSelect["Light " + i] = i;
			lightsFolder.add(text, 'selectedLight', lightsToSelect).name('Lights');
			lightsFolder.addColor(text, 'lightColor').name('Color').onChange(function(value) {
				if (text.allLights)
					for (var i = 0 ; i < lights.length ; i++) {
						lights[i].setHexaColor(value);
						lightsColor[i] = lights[i].getColor();
					}
				else {
					lights[text.selectedLight].setHexaColor(value);
					lightsColor[text.selectedLight] = lights[text.selectedLight].getColor();
				}
				render();
			});
			lightsFolder.add(text, 'lightIntensity', 0.0, 2.0).name('Intensity').onChange(function(value) {
				if (text.allLights)
					for (var i = 0 ; i < lights.length ; i++)
						lightsIntensity[i] = value;
				else
					lightsIntensity[text.selectedLight] = value;
				render();
			});
			lightsFolder.add(text, 'lightAngle', 0.0, 360.0).name('Angle').onChange(function(value) {
				if (text.allLights)
					for (var i = 0 ; i < lights.length ; i++)
						lightsAngle[i] = value;
				else
					lightsAngle[text.selectedLight] = value;
				render();
			});
			lightsFolder.add(text, 'lightAttenuation', 0.0, 5.0).name('Attenuation').onChange(function(value) {
				if (text.allLights)
					for (var i = 0 ; i < lights.length ; i++)
						lightsAttenuation[i] = value;
				else
					lightsAttenuation[text.selectedLight] = value;
				render();
			});
			lightsFolder.open();
			
			var shadowsFolder = gui.addFolder("Shadows");
			shadowsFolder.add(text, 'mapsResolution', 0, 512).name("Shadow maps resolution").onChange(function(value) {
				shadowMapsResolution = Math.round(value);
				refactorShadowMaps();
				render();
			});
			shadowsFolder.open();
		}
	
		init();
		initControls();
		animate();
		
		// process lights for shaders
		function processLights() {
			var lightsNumber = lights.length;
			for (var i = 0 ; i < lights.length ; i++) {
				lightsPos[i] = lights[i].getPosition();
				lightsColor[i] = lights[i].getColor();
				lightsIntensity[i] = lights[i].getIntensity();
				
				lightsCameras[i] = new THREE.PerspectiveCamera(70.0, 1.0, 0.1, 1000.0);
				lightsCameras[i].position = lightsPos[i];
				lightsCameras[i].lookAt(lights[i].getLookAt()); 
				
				lightsView[i] = lightsCameras[i].matrixWorldInverse;
				lightsProj[i] = lightsCameras[i].projectionMatrix;
				
				lightsRot[i] = new THREE.Matrix3();
				lightsRot[i].getNormalMatrix(lightsView[i]);
				lightsRot[i] = lightsCameras[i].rotation;
				//lightsCameras[i].updateMatrix();
				
				lightsAngle[i] = lightDefaultAngle;
				lightsAttenuation[i] = lightDefaultAttenuation;
			
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			}
		}
		
		function refactorShadowMaps() {
			for (var i = 0 ; i < lights.length ; i++) {
				shadowMaps[i] = new THREE.WebGLRenderTarget(shadowMapsResolution, shadowMapsResolution, options);
			}
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag', 'shadowMap1');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag', 'shadowMap2');
			displayManager.organize();
		}
		
		// Initialization of the world
		function initScene() {
			scene = new THREE.Scene();
			sceneScreen = new THREE.Scene();
			//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
			
			// lights
			lights[0] = new Light(
				new THREE.Vector3(250, 200, 180),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0),
				1.0
			);
			lights[1] = new Light(
				new THREE.Vector3(-200, 400, 150),
				new THREE.Vector4(1.0, 1.0, 1.0, 1.0),
				1.0
			);
			processLights();
			
			// shaders & textures
			shaders['phong'] = new PhongShader(lightsPos, lightsColor, lightsIntensity);
			rtTextures['phong'] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			shaders['expressive'] = new ExpressiveShader(lightsPos, lightsColor, lightsIntensity);
			rtTextures['expressive'] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			shaders['diffuse'] = new DiffuseShader(lightsPos, lightsColor, lightsIntensity);
			rtTextures['diffuse'] = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			normalsAndDepthShader = new Shader();
			normalsAndDepthShader.loadShader('shaders/default.vert', 'vertex');
			normalsAndDepthShader.loadShader('shaders/computesNormalsDepth.frag', 'fragment');
			normalsAndDepthTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			// SSDO required inputs
			coordsShader = new Shader();
			coordsShader.loadShader('shaders/computesCoords.vert', 'vertex');
			coordsShader.loadShader('shaders/computesCoords.frag', 'fragment');
			coordsTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			diffuseMapShader = new Shader();
			diffuseMapShader.loadShader('shaders/default.vert', 'vertex');
			diffuseMapShader.loadShader('shaders/diffuseMap.frag', 'fragment');
			diffuseTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			
			// shadow mapping
			shadowMapsShader = new Shader();
			shadowMapsShader.loadShader('shaders/shadowMaps.vert', 'vertex');
			shadowMapsShader.loadShader('shaders/shadowMaps.frag', 'fragment');
			//shadowMapsShader.setUniform('lightsProj', 'm4v', lightsProj);
			
			// hard shadows
			hardShadowsTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			hardShadowsShader = new Shader();
			hardShadowsShader.loadShader('shaders/worldCoords.vert', 'vertex');
			hardShadowsShader.loadShader('shaders/hardShadows.frag', 'fragment');
			hardShadowsShader.setUniform('shadowMaps', 'vt', shadowMaps);
			hardShadowsShader.setUniform('shadowMap', 't', shadowMaps[0]);
			hardShadowsShader.setUniform('shadowMap1', 't', shadowMaps[1]);
			hardShadowsShader.setUniform('lightsView', 'm4v', lightsView);
			hardShadowsShader.setUniform('lightsProj', 'm4v', lightsProj);
			hardShadowsShader.setUniform('lightsRot', 'm3v', lightsRot);
			hardShadowsShader.setUniform('lightsPos', 'v3v', lightsPos);
			hardShadowsShader.setUniform('lightsColor', 'v4v', lightsColor);
			hardShadowsShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			hardShadowsShader.setUniform('lightsAngle', 'fv1', lightsAngle);
			hardShadowsShader.setUniform('skyLightIntensity', 'f', skyLightIntensity);
			hardShadowsShader.setUniform('PI', 'f', Math.PI);
			hardShadowsShader.setUniform('lightsAttenuation', 'fv1', lightsAttenuation);
			//hardShadowsShader.setUniform('worldMatrix', 'm4', camera.matrixWorldInverse);
			
			// SSDO shaders
			directLightBuffer = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, options);
			ssdoDirectLightingShader = new Shader();
			ssdoDirectLightingShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoDirectLightingShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoDirectLightingShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoDirectLightingShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoDirectLightingShader.loadShader('shaders/SSDODirectLighting.frag', 'fragment');
			ssdoDirectLightingShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoDirectLightingShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoDirectLightingShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoDirectLightingShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoDirectLightingShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoDirectLightingShader.setUniform('projectionM', 'mat4', camera.projectionMatrix);
			//ssdoDirectLightingShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoIndirectBounceShader = new Shader();
			ssdoIndirectBounceShader.loadShader('shaders/ssdo.vert', 'vertex');
			ssdoIndirectBounceShader.loadShader('shaders/SSDOIndirectBounce.frag', 'fragment');
			ssdoIndirectBounceShader.setUniform('directLightBuffer', 't', directLightBuffer);
			ssdoIndirectBounceShader.setUniform('positionsBuffer', 't', coordsTexture);
			ssdoIndirectBounceShader.setUniform('normalsAndDepthBuffer', 't', normalsAndDepthTexture);
			ssdoIndirectBounceShader.setUniform('diffuseTexture', 't', diffuseTexture);
			ssdoIndirectBounceShader.setUniform('screenWidth', 'f', window.innerWidth);
			ssdoIndirectBounceShader.setUniform('screenHeight', 'f', window.innerHeight);
			ssdoIndirectBounceShader.setUniform('lightsPos', 'v3v', lightsPos);
			ssdoIndirectBounceShader.setUniform('lightsColor', 'v4v', lightsColor);
			ssdoIndirectBounceShader.setUniform('lightsIntensity', 'fv1', lightsIntensity);
			ssdoIndirectBounceShader.setUniform('projectionM', 'mat4', camera.projectionMatrix);
			//ssdoIndirectBounceShader.setUniform('cameraPosition', 'vec3', camera.position);
			
			ssdoScene = new THREE.Scene();
			var plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
			ssdoQuad = new THREE.Mesh(plane);
			ssdoScene.add(ssdoQuad);
			
			// sphere
			var sphereMaterial = new THREE.MeshLambertMaterial({color: 0xCC0000});
			var radius = 50, segments = 16, rings = 16;
			var sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
			objects[0] = new THREE.Mesh(sphereGeometry);
			materials[0] = jQuery.extend(true, {}, blankMaterial);
			materials[0]['matSpecular'] = 0.8;
			materials[0]['matDiffuseColor'] = new THREE.Vector4(1.0, 0.0, 0.0, 1.0);
			scene.add(objects[0]);
			//objects[0].add(camera);
			
			var geometry = new THREE.CylinderGeometry(0, 10, 30, 4, 1);
			objects[1] = new THREE.Mesh(geometry);
			objects[1].position.x = -100;
			objects[1].position.z = -100;
			objects[1].position.y = -50;
			materials[1] = materials[0];
			scene.add(objects[1]);
			
			// off importation
			loadOFF('models/monkey.off');
			objects[2].position.x = 150;
			materials[2] = jQuery.extend(true, {}, blankMaterial);
			materials[2]['matDiffuseColor'] = new THREE.Vector4(0.2, 1.0, 0.2, 1.0);
			scene.add(objects[2]);
			
			loadOFF('models/ram.off');
			objects[3].position.x = -80;
			objects[3].position.z = 100;
			objects[3].position.y = -50;
			objects[3].rotation.x = - Math.PI / 2;
			materials[3] = jQuery.extend(true, {}, blankMaterial);
			materials[3]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.0, 0.5, 1.0);
			scene.add(objects[3]);
			
			loadOFF('models/ground.off', 200);
			objects[4].position.y = -100;
			objects[4].rotation.x = - Math.PI / 2;
			materials[4] = jQuery.extend(true, {}, blankMaterial);
			materials[4]['matDiffuseColor'] = new THREE.Vector4(0.5, 0.5, 0.5, 1.0);
			scene.add(objects[4]);
			
			//phongShader.setAttribute('displacement', 'f', []);
			// now populate the array of attributes
			/*var vertices = sphere.geometry.vertices;
			var values = attributes.displacement.value
			for(var v = 0; v < vertices.length; v++) {
				values.push(Math.random() * 30);
			}*/
			
			// displays for the different renderings
			displayManager = new DisplayManager(sceneScreen, {type: 'GRID', cols: 2, rows: 3});
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepth.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayNormals.frag');
			displayManager.addCustomTexture(normalsAndDepthTexture, 'shaders/displayDepthNormals.frag');
			displayManager.addSimpleTexture(rtTextures['phong'], 'phong');
			displayManager.addSimpleTexture(rtTextures['expressive'], 'expressive');
			displayManager.addSimpleTexture(rtTextures['diffuse']);
			displayManager.addSimpleTexture(diffuseTexture);
			displayManager.addCustomTexture(shadowMaps[0], 'shaders/displayShadowMap.frag', 'shadowMap1');
			displayManager.addCustomTexture(shadowMaps[1], 'shaders/displayShadowMap.frag', 'shadowMap2');
			displayManager.addSimpleTexture(hardShadowsTexture, 'hardShadows');
			displayManager.addSimpleTexture(directLightBuffer, 'ssdoDirect');
			displayManager.addSimpleTexture(ssdoFinalBuffer, 'ssdoFinal');
			displayManager.organize();
			
			if (MODE == 'SHADOWS')
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 2, names: shadowGrid});
			else if (MODE == 'SSDO')
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 1, names: ssdoGrid});
		}
		
		// Initialization
		function init() {
			camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
			//camera.position.x = 200;
			camera.position.y = 200;
			camera.position.z = 300;
			
			cameraRTT = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000);
			cameraRTT.position.z = 100;
			
			// world
			initScene();
			
			// renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xFFFFFF, 1);
			renderer.setSize(screenWidth, screenHeight);
			
			// controls
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [65, 83, 68];
			controls.addEventListener('change', render);

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			
			// control panel
			//var $controlPanel = $('#controlPanel');
			//$controlPanel.style.position = 'aboslute';
			//$controlPanel.style.top = '0px';
			
			// display
			$container = $('#container');
			$container.append(renderer.domElement);
			$container.append(stats.domElement);
			//$container.append($controlPanel);
			
			window.addEventListener('resize', onWindowResize, false);
			window.addEventListener('keydown', keyDown, false);
		}
		
		function keyDown(event) {
			if (event.keyCode == 65) // a
				ANIMATION = !ANIMATION;
			else if (event.keyCode == 79) { // o
				MODE = 'NORMAL';
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 3});
			}
			else if (event.keyCode >= 97 && event.keyCode <= 105) { // 1 to 9
				if (MODE == 'NORMAL')
					displayManager.changeMode({type: 'SINGLE', id: (event.keyCode - 97)});
				else if (MODE == 'SHADOWS')
					displayManager.changeMode({type: 'SINGLE', name: shadowGrid[event.keyCode - 97]});
				else if (MODE == 'SSDO')
					displayManager.changeMode({type: 'SINGLE', name: ssdoGrid[event.keyCode - 97]});
			}
			else if (event.keyCode == 80) { // p
				MODE = 'NORMAL';
				displayManager.changeMode({type: 'SINGLE', name: 'phong'});
			}
			else if (event.keyCode == 69) { // e
				MODE = 'NORMAL';
				displayManager.changeMode({type: 'SINGLE', name: 'expressive'});
			}
			else if (event.keyCode == 83) { // s
				MODE = 'SHADOWS';
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 2, names: shadowGrid});
			}
			else if (event.keyCode == 68) { // d
				MODE = 'SSDO';
				displayManager.changeMode({type: 'GRID', cols: 2, rows: 1, names: ssdoGrid});
			}
			render();
		}
	
		function render() {
			if (MODE == 'NORMAL' || MODE == 'SHADOWS' || MODE == 'SSDO') {
				// 1st rendering : computes depth and normals
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(normalsAndDepthShader.getMaterial());
				renderer.render(scene, camera, normalsAndDepthTexture, true);
			}
			
			if (MODE == 'NORMAL') {
				// 2nd rendering : complete rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['phong'].use(materials[i]['matDiffuse'], materials[i]['matSpecular'], materials[i]['shininess'], materials[i]['matDiffuseColor'], materials[i]['matSpecularColor'], materials[i]['matEmissive'], materials[i]['matEmissiveColor']);
					objects[i].setMaterial(shaders['phong'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['phong'], true);
				
				// 3rd rendering : expressive rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['expressive'].use(materials[i]['matDiffuse'], materials[i]['shininess'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['expressive'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['expressive'], true);
			
				// 4th rendering : diffuse material rendering
				for (var i = 0 ; i < objects.length ; i++) {
					shaders['diffuse'].use(materials[i]['matDiffuse'], materials[i]['matDiffuseColor']);
					objects[i].setMaterial(shaders['diffuse'].createMaterial());
				}
				renderer.render(scene, camera, rtTextures['diffuse'], true);
			}
			
			if (MODE == 'SSDO') {
				// 5th rendering : diffuse map rendering
				for (var i = 0 ; i < objects.length ; i++) {
					diffuseMapShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					diffuseMapShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					objects[i].setMaterial(diffuseMapShader.createMaterial());
				}
				renderer.render(scene, camera, diffuseTexture, true);
			}
			
			if (MODE == 'SHADOWS') {
				// shadow maps
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(shadowMapsShader.getMaterial());
				renderer.render(scene, lightsCameras[0], shadowMaps[0], true);
				renderer.render(scene, lightsCameras[1], shadowMaps[1], true);
				
				for (var i = 0 ; i < objects.length ; i++) {
					hardShadowsShader.setUniform('matDiffuse', 'f', materials[i]['matDiffuse']);
					hardShadowsShader.setUniform('matSpecular', 'f', materials[i]['matSpecular']);
					hardShadowsShader.setUniform('shininess', 'f', materials[i]['shininess']);
					hardShadowsShader.setUniform('matDiffuseColor', 'v4', materials[i]['matDiffuseColor']);
					hardShadowsShader.setUniform('matSpecularColor', 'v4', materials[i]['matSpecularColor']);
					objects[i].setMaterial(hardShadowsShader.createMaterial());
				}
				renderer.render(scene, camera, hardShadowsTexture, true);
			}
			
			// SSDO
			if (MODE == 'SSDO') {
				// computes 3D coords
				for (var i = 0 ; i < objects.length ; i++)
					objects[i].setMaterial(coordsShader.getMaterial());
				renderer.render(scene, camera, coordsTexture, true);
				
				// ssdo 1st pass
				ssdoQuad.setMaterial(ssdoDirectLightingShader.getMaterial());
				renderer.render(ssdoScene, cameraRTT, directLightBuffer, true);
				// ssdo 2nd pass
				ssdoQuad.setMaterial(ssdoIndirectBounceShader.getMaterial());
				renderer.render(ssdoScene, cameraRTT, ssdoFinalBuffer, true);
			}
			
			// displays the scene
			renderer.render(sceneScreen, cameraRTT);
		}
		
		// requestAnim shim layer by Paul Irish
		window.requestAnimFrame = (function() {
			return	window.requestAnimationFrame       || 
					window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     || 
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
		})();

		var direction = 1;
		var lastTime = (new Date()).getTime();
		var currentTime = lastTime;
		var interval = 20;
		
		function animate() {
			requestAnimationFrame(animate);
			currentTime = (new Date()).getTime();
			if (ANIMATION) {
				if (currentTime - lastTime >= interval) {
					if (objects[0].position.y >= 100)
						direction = -1;
					if (objects[0].position.y <= -50)
						direction = 1;
					objects[0].position.y += direction * 5;
					lastTime = currentTime;
					render();
				}
			}
			controls.update();
			stats.update();
		}
		
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

			render();
		}
	</script>
</html>